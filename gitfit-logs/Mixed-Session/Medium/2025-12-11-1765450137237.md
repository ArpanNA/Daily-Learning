# GitFit Challenge: Mixed-Session

**Date:** 2025-12-11
**Difficulty:** Medium
**Type:** DSA / LeetCode
**Time Taken:** 81s

## Question
You are given an array of integers `nums`. Your task is to find the maximum possible sum of a non-empty subarray, with the option to delete at most one element from that subarray. The resulting subarray (after the optional deletion) must remain non-empty.

Note: If you choose not to delete any element, the problem simplifies to the standard Maximum Subarray Sum problem (Kadane's algorithm). If you choose to delete an element, the remaining parts must still form a valid contiguous non-empty sequence.

Implement the function:

python
def max_sum_one_deletion(nums: list[int]) -> int:
    pass


Example:
Input: `nums = [1, -2, 0, 3]`
Output: 4 
(Explanation: The subarray `[1, -2, 0, 3]` with deletion of -2 yields `[1, 0, 3]`, sum 4. If we chose not to delete anything, the max subarray is `[0, 3]`, sum 3.)

## My Answer
```text
def max_sum_one_deletion(nums: list[int]) -> int:
    n = len(nums)
    
    keep = nums[0]        # Max subarray ending here with no deletion
    delete = float('-inf')  # Max subarray ending here with one deletion already
    result = nums[0]
    
    for i in range(1, n):
        num = nums[i]
        
        # Update delete state first (since it depends on previous keep)
        delete = max(delete + num, keep)
        
        # Update keep state (standard Kadane)
        keep = max(keep + num, num)
        
        # Track the global max
        result = max(result, keep, delete)
    
    return result

```

## AI Feedback
This dynamic programming approach correctly solves the Maximum Subarray Sum with One Deletion problem. It efficiently tracks two states: the max sum ending at the current index without deletion (`keep`) and the max sum ending at the current index after exactly one deletion (`delete`).

> Verified by GitFit AI